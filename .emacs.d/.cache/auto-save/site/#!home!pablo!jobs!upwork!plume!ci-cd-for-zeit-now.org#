* CI/CD for Zeit Now
#+BEGIN: clocktable :scope subtree :maxlevel 2
#+CAPTION: Clock summary at [2019-04-30 Tue 23:34]
| Headline                                    | Time    |      |
|---------------------------------------------+---------+------|
| *Total time*                                | *13:14* |      |
|---------------------------------------------+---------+------|
| CI/CD for Zeit Now                          | 13:14   |      |
| \_  EXTRAS                                  |         | 1:42 |
| \_  INTRO                                   |         | 0:06 |
| \_  Meet the application                    |         | 1:24 |
| \_  Serverless platforms                    |         | 1:29 |
| \_  What's all the buzz about Continuous... |         | 0:12 |
| \_  Continuous Integration Pipeline         |         | 0:24 |
| \_  Putting it all together                 |         | 0:32 |
#+END:

  :LOGBOOK:
  CLOCK: [2019-04-30 Tue 15:43]--[2019-04-30 Tue 16:33] =>  0:50
  CLOCK: [2019-04-30 Tue 12:15]--[2019-04-30 Tue 12:25] =>  0:10
  CLOCK: [2019-04-30 Tue 09:29]--[2019-04-30 Tue 09:34] =>  0:05
  CLOCK: [2019-04-29 Mon 21:12]--[2019-04-29 Mon 21:49] =>  0:37
  CLOCK: [2019-04-27 Sat 15:31]--[2019-04-27 Sat 15:43] =>  0:12
  CLOCK: [2019-04-29 Mon 20:51]--[2019-04-29 Mon 21:05] =>  0:14
  CLOCK: [2019-04-29 Mon 18:18]--[2019-04-29 Mon 18:44] =>  0:26
  CLOCK: [2019-04-29 Mon 17:31]--[2019-04-29 Mon 17:43] =>  0:12
  CLOCK: [2019-04-29 Mon 00:04]--[2019-04-29 Mon 00:16] =>  0:12
  CLOCK: [2019-04-27 Sat 19:26]--[2019-04-27 Sat 19:33] =>  0:07
  CLOCK: [2019-04-26 Fri 13:54]--[2019-04-26 Fri 14:05] =>  0:11
  CLOCK: [2019-04-29 Mon 16:58]--[2019-04-29 Mon 17:24] =>  0:26
  CLOCK: [2019-04-29 Mon 16:45]--[2019-04-29 Mon 16:58] =>  0:13
  CLOCK: [2019-04-29 Mon 16:21]--[2019-04-29 Mon 16:39] =>  0:18
  CLOCK: [2019-04-27 Sat 10:48]--[2019-04-27 Sat 11:14] =>  0:26
  CLOCK: [2019-04-26 Fri 18:14]--[2019-04-26 Fri 18:16] =>  0:02
  CLOCK: [2019-04-26 Fri 14:42]--[2019-04-26 Fri 14:43] =>  0:01
  CLOCK: [2019-04-28 Sun 21:13]--[2019-04-28 Sun 21:24] =>  0:11
  CLOCK: [2019-04-26 Fri 14:22]--[2019-04-26 Fri 14:23] =>  0:01
  CLOCK: [2019-04-28 Sun 20:51]--[2019-04-28 Sun 20:56] =>  0:05
  CLOCK: [2019-04-28 Sun 13:17]--[2019-04-28 Sun 13:54] =>  0:37
  CLOCK: [2019-04-28 Sun 12:33]--[2019-04-28 Sun 13:11] =>  0:38
  CLOCK: [2019-04-27 Sat 14:33]--[2019-04-27 Sat 14:41] =>  0:08
  CLOCK: [2019-04-27 Sat 14:05]--[2019-04-27 Sat 14:25] =>  0:15
  CLOCK: [2019-04-27 Sat 13:56]--[2019-04-27 Sat 14:15] =>  0:19
  CLOCK: [2019-04-27 Sat 13:45]--[2019-04-27 Sat 13:52] =>  0:07
  CLOCK: [2019-04-27 Sat 13:23]--[2019-04-27 Sat 13:38] =>  0:18
  CLOCK: [2019-04-27 Sat 12:08]--[2019-04-27 Sat 12:10] =>  0:02
  :END:
# Won't set you back at all
** TASK
Continuation from use case docs. Should be more step by step, as if you're not familiar with neither Semaphore 2.0 nor Zeit Now.
** EXTRAS
*** Layout
    :LOGBOOK:
    CLOCK: [2019-04-26 Fri 13:41]--[2019-04-26 Fri 13:46] =>  0:05
    CLOCK: [2019-04-25 Thu 17:55]--[2019-04-25 Thu 18:02] =>  0:07
    CLOCK: [2019-04-25 Thu 17:33]--[2019-04-25 Thu 17:36] =>  0:03
    :END:
*** Profreading
    :LOGBOOK:
    CLOCK: [2019-04-30 Tue 22:58]--[2019-04-30 Tue 23:25] =>  0:27
    CLOCK: [2019-04-30 Tue 21:58]--[2019-04-30 Tue 22:58] =>  1:00
    :END:
** [Feedback]
   :LOGBOOK:
   CLOCK: [2019-05-16 Thu 15:09]--[2019-05-16 Thu 15:09] =>  0:00
   :END:
Overall good job!

I've been thinking about where to publish, and decided to submit the article to Hackernoon, with title "Serverless CI/CD and hosting with Semaphore and Zeit Now". It's a very popular Medium publication. So, imagine this post as is there. :)

And before submitting I'd like to send it to Zeit team for feedback (and to make them more eager to share on their channels).

I think there are a few implications.

The intro needs to be adjusted. In this post we will learn all about continuous integration and delivery and how we can use it to our advantage. — I think you'd need to change the first sentence regardless of where we post, since it's too general. The article is (I imagine) appealing to people who have been practicing CI/CD in the past but with now-old tools like Jenkins and provisioning own servers.

On contrary both Zeit and Semaphore provide a "serverless" user experience in their departments. With Zeit you don't worry where your code runs at any scale, it just instantly works on a domain with https. Similarly, Semaphore just works and scales up CI/CD to any git push, and back to zero.

Then I think a few adjustments are needed when introducing tools. Assume the reader doesn't know neither Semaphore nor Zeit, and present them equally. So to an external reader it should not be obvious that you're on team Semaphore.

See if you can say a few more technical things about Zeit that makes them interesting. Just take what are relatively innovative technical facts from their website.
** INTRO
   :LOGBOOK:
   CLOCK: [2019-04-26 Fri 13:50]--[2019-04-26 Fri 13:54] =>  0:04
   CLOCK: [2019-04-26 Fri 13:46]--[2019-04-26 Fri 13:48] =>  0:02
   :END:

# Are you getting started with programming?
# Do you wish to know what's all the rage these days?

In this post we will learn all about continuous integration and
delivery and how we can use it to our advantage.
Whether you are a seasoned developer or just dabbling in programming,
continuous integration is a powerful addition to every developer's toolkit.

** Meet the application
   :LOGBOOK:
   CLOCK: [2019-04-30 Tue 09:37]--[2019-04-30 Tue 09:53] =>  0:16
   CLOCK: [2019-04-28 Sun 23:26]--[2019-04-28 Sun 23:55] =>  0:29
   CLOCK: [2019-04-28 Sun 22:47]--[2019-04-28 Sun 22:52] =>  0:05
   CLOCK: [2019-04-26 Fri 18:13]--[2019-04-26 Fri 18:14] =>  0:01
   CLOCK: [2019-04-26 Fri 14:36]--[2019-04-26 Fri 14:42] =>  0:06
   :END:

During the course this post we will work with the [[https://github.com/semaphoreci-demos/semaphore-demo-zeit-now][Semaphore Demo app]].
Step by step, we'll see how to get it online and how make part of a continuous
delivery process.

The project consists of a simple API Server that functions as [[https://en.wikipedia.org/wiki/%22Hello,_World!%22_program][Hello World!]] program.
That may not sound very exciting, but APIs are how applications communicate
with each other over the web.
So mastering them is really a must for every developer.

The server is written for [[https://nodejs.org][Node.js]] and uses a few extra modules:

- [[http://expressjs.com/][Express]]

Express is a framework designed for building websites and APIs.
Its popularity has made it de facto for web development.

In contrast with other frameworks, Express doesn't force us to
adopt any particular design pattern.
Instead, it only provides the bare minimum functionality which can be extended with
middleware.
# It supplies the bare minimum code to build
# It tends to be minimalist, with the minimal number of features to get the job done.

# Express doesn't force the programmer to adopt any particular design pattern. We
# can choose to use an MVC pattern if we wish so, or use any other design.

# It also doesn't ship with any data modeling modules, that is left to third-party modules.
# No auth also, no template engine.

# Many exampes designs: https://github.com/expressjs/express/tree/master/examples

# view engines: pug, handlebars

- [[https://helmetjs.github.io/][Helmet]]

Helmet is middleware that provides enhanced security for Express.
It can prevent exploits such as cross-site scripting (XSS)
and click-jacking by adding special headers in the HTTP messages.
# Once added it does its thing silently in the background.
# to prevent things such as:
# XSS: cross-site scripting
# DNS Prefetching control
# Clickjack prevention.

- [[https://jestjs.io/][Jest]]

Testing is vital in any development, not only to find bugs but also to validate that the
code does exactly what it has been designed to do.
Jest implements unit testing, a technique that runs small pieces of
code and checks the results.

# Jest can also check if there are parts of the code that are not executed and
# print out a coverage report.



# Provide high level abstraction for testing HTTP
# Makes HTTP requests

# - [[https://nodemon.io/][nodemon]]

# Restart app automatically when code changes.

*** Setting up your dev environment
    :LOGBOOK:
    CLOCK: [2019-04-29 Mon 16:44]--[2019-04-29 Mon 16:45] =>  0:01
    CLOCK: [2019-04-26 Fri 18:17]--[2019-04-26 Fri 18:34] =>  0:17
    CLOCK: [2019-04-26 Fri 14:43]--[2019-04-26 Fri 14:44] =>  0:01
    :END:

Before advancing further, you may need to install some tools on your machine.
You should check if you have installed the *Node.js* and *npm* bundle:

# To check if your system has it, try the following commands:

  #+BEGIN_SRC bash
  $ node -v
  $ npm -v
  #+END_SRC

If you need to install them, instructions can be found at the [[https://nodejs.org/en/download/][Node.js]] website.

To work with the code, you will also need [[https://git-scm.com/downloads][git]]. Check if you already have it installed:

  #+BEGIN_SRC bash
  $ git --version
  #+END_SRC

Lastly, while not strictly necessary, it's a good idea to get [[https://curl.haxx.se/][curl]], the Swiss
army knife of networking. It's very handy to view the responses from servers.

  #+BEGIN_SRC bash
  $ curl --version
  #+END_SRC

# Now, once you have git, you could copy the app to your machine.
# But, we can do something better, Fork!
# Forking a project is ....

*** Fork and run the demo
    :LOGBOOK:
    CLOCK: [2019-04-27 Sat 00:30]--[2019-04-27 Sat 00:38] =>  0:08
    :END:

To get your own copy of the project, fork the repository on GitHub:

1. Create a [[https://github.com][GitHub]] account.
2. Go to the [[https://github.com/semaphoreci-demos/semaphore-demo-zeit-now][Demo app]] repository.
3. Click on the *Fork* button on the top right side.
4. Click on the *Clone or download* button and copy the URL.
5. Get the code:

  #+BEGIN_SRC bash
  $ git clone https://github.com/<YOUR_REPOSITORY_URL>
  #+END_SRC

The next thing is to build and test the app:

1. Install the required packages:

  #+BEGIN_SRC bash
  $ npm install
  #+END_SRC

2. And run the test suite:

  #+BEGIN_SRC bash
  $ npm test

  > express-ziet-now-semaphore-ci@1.0.0 test semaphore-demo-zeit-now
  > NODE_ENV=test PORT=3000 jest --coverage --bail

  PASS  test/integration/index.test.js
    :index
      ✓ [GET /] Should get server is running response (54ms)

    console.log test/index.js:12
      Server running on port 3000.

    console.info test/_testUtils/ApiClient.js:20
      ---REQUEST.BODY---

    console.info test/_testUtils/ApiClient.js:21
      {}

    console.info test/_testUtils/ApiClient.js:22
      ---RESPONSE.BODY---

    console.info test/_testUtils/ApiClient.js:23
      {
        "text": "Hello from express server."
      }

  ---------------------|----------|----------|----------|----------|-------------------|
  File                 |  % Stmts | % Branch |  % Funcs |  % Lines | Uncovered Line #s |
  ---------------------|----------|----------|----------|----------|-------------------|
  All files            |      100 |      100 |      100 |      100 |                   |
  index.controller.js |      100 |      100 |      100 |      100 |                   |
  ---------------------|----------|----------|----------|----------|-------------------|
  Test Suites: 1 passed, 1 total
  Tests:       1 passed, 1 total
  Snapshots:   1 passed, 1 total
  Time:        1.591s
  Ran all test suites.

  #+END_SRC

Jest prints quite a lot of output. The first part is the result of the unit testing.
We only have one test: check if the server's response is valid JSON.
The second part is the coverage report: it tells us whether any part of the code was not executed.
No problems found, so far so good.
# So far so good, t

# if there are any untested parts. The test passes, everything looks good.

The only thing left to do is to get the app started:

  #+BEGIN_SRC bash
  $ npm start
  #+END_SRC

You can view the response from your server either with curl or by opening your browser to [[http://127.0.0.1:3000]]:

  #+BEGIN_SRC bash
  $ curl -w "\n" http://127.0.0.1:3000

  {"text":"Hello from express server."}
  #+END_SRC

You got it working. Way to go!

** Serverless platforms
   :LOGBOOK:
   CLOCK: [2019-04-26 Fri 14:23]--[2019-04-26 Fri 14:32] =>  0:09
   :END:

Who wants to deal with servers, install patches and upgrade databases? No one, that's who.
Let sysadmins deal with what's under the hood, you only want to code.
Serverless platforms, also known as platform-as-a-service, take away all the
drudgery of managing infrastructure.
As if it that wasn't enough to jump on the serverless bandwagon, we also get auto scaling: as demand
increases, more resources are automatically allocated to cope with the higher load.

Luckily, nowadays we have lots of cool alternatives to pick from. We'll be
using [[https://zeit.co][Zeit Now]].


# When was the last time anyone said, I feel like debugging a stack dump. I'll
# tell you when that happened: never.
# Let sysadmin, dbas and devops folks deal with that, it's their problem.
# , you only want to code right?

#  and lets you focus only on the application.
# provide advanced functions such as auto-provisioning and auto-scaling,
# so we don't even have to worry about performance if the app goes viral.

# Serverless is a bit of a confusing name, though.
# In the background, there are always servers it's just that we don't need to know about
# them.
# , wheter virtual machines, docker images, containers
# or other technology.
# There are servers, it's just that you don't know about them.

*** About Zeit Now
    :LOGBOOK:
    CLOCK: [2019-04-30 Tue 11:04]--[2019-04-30 Tue 11:31] =>  0:27
    CLOCK: [2019-04-29 Mon 16:58]--[2019-04-29 Mon 16:58] =>  0:00
    CLOCK: [2019-04-27 Sat 10:44]--[2019-04-27 Sat 10:48] =>  0:04
    CLOCK: [2019-04-26 Fri 14:32]--[2019-04-26 Fri 14:36] =>  0:04
    :END:

# We will be hosting the app on Zeit Now.
# We're using Zeit Now to make the app available online.
Deploying an app on Zeit Now takes literally one command.
And it plays really well with the continuous delivery setup coming next.

# Zeit Now supports Node.js, PHP and Go out of the box, with the possibility of
# adding more languages.

# We'll be using Zeit Now, because it makes deployments oh so easy.
# What I love about Zeit Now is that it is so easy to publish the app. We can do
# it with a single command. Zeit Now provides Node.js, Go and PHP out of the box.

Apps in Zeit Now are immutable,
i.e. once deployed, they cannot be changed.
Each new published version gets a unique deployment URL.
As it turns out, this clever approach allows us to roll back to any previous
version at any time if there are any problems.

# A fixed URL is always associated with the latest version, this is our public
# facing address.
# Zeit Now also creates a fixed URL which is always aliased to the most current
# version. This is the address for our users.

# In Zeit Now, URLs follow this format by default:
By default, Zeit Now addresses follow this format:

# Zeit Now uses immutable structures it sites, i.e. uploading a new version of the
# app doesn't overwrite the existing one, but creates a new site.
# To handle multiple versions of the site, Zeit Now uses two kinds of URLS:

- ~https://APP_NAME.USERNAME.now.sh~: Public URL that points to the latest
  version. This is the public facing address.
- ~https://APP_NAME-UUID.now.sh~: Deployment URL. UUID is a unique,
  automatically generated string for each version.
#  URL vs aliases
#  URL -> deployment url
#  Alias -> public facing name

# https://zeit.co/tomfern/semaphore-demo/3uoo1amc7

# semaphore-demo.tomfern.now.sh

# This approach lets us easily manage multiple versions of the site and makes it
# really easy to rollback if you find any issues. Just point the alias to another deployment
# URL.


# Zeit Now has a smart approach for deployments.
# Zeit has an interesting approach for the deploying process.
# Any programmer getting started with Zeit would expect new deploys to overwrite
# old ones. I know I did.
# But no, each deploy goes into it's own URL, and the last one is mapped to the
# public URL alias.
# It's all due to the immutable structure approach. Once a deployment is made, is
# never again modified. That way we can see previous versions of the app from our dashboard.


# Zeit Now can run

# Zeit Now is a serverless platform.
# It supports nodejs, etc etc etc
# What's nice about Zeit Now is that is oh so easy to deploy.
# Their official Now CLI tool is pure magic.
# Look at this:

# [ now deploy example ! ]

# How many commands I had to use? Exactly one. I cheated though, because I had to
# install the tool and login. But the point stands


# Zeit provides its own domain by default, but we can also use our own domains.

# ZEIT THEORY
# Immutable structures
# No native DB service
# DNS nameservers, external name servers supported but need to be verified
# What about if you have a domain?
# Many deployments for a project, hierarchy?

*** Deploy from your machine
    :LOGBOOK:
    CLOCK: [2019-04-29 Mon 18:44]--[2019-04-29 Mon 18:54] =>  0:10
    CLOCK: [2019-04-27 Sat 16:27]--[2019-04-27 Sat 16:50] =>  0:23
    CLOCK: [2019-04-27 Sat 10:32]--[2019-04-27 Sat 10:44] =>  0:12
    :END:

Enough theory.
Time to get this app online:
# The hard part is over.The next step is putting the app online. If you managed to
# get the app running on your computer, this part should be a piece of cake:

1. Create a [[https://zeit.co][Zeit Now]] account.
2. Install the official ~now~ tool:

  #+BEGIN_SRC bash
  $ npm install now -g
  #+END_SRC

3. Connect your machine to Zeit Now:

  #+BEGIN_SRC bash
  $ now login
  #+END_SRC

4. Follow the on-screen instructions.

# Once logged in, we can start the deployment.
# ~now~ provides multiple options to configure deployments.
# We opt for config file because it makes it easier for us to work later on the
# continuous delivery part.

The project already ships with two deployment files:
~production.json~ and ~staging.json~. Production is our public facing site,
while staging will act as a guinea pig and playground for us to test things out.

Take a look at ~staging.json~:

  #+BEGIN_SRC json
  {
    "version": 2,
    "name": "semaphore-demo-staging",
    "builds": [
        { "src": "**/*.js", "use": "@now/node" }
    ]
  }
  #+END_SRC

This is the minimum information that ~now~ needs to make a deployment. The
config defines the ~name~ of the application and which files to include in the build.

# The deployment URL looks like this : ~<NAME>-<UID>.now.sh~

# - ~<NAME>~ is the deployment name, the name from the config
# - ~<UID>~ is a random 9 alpha character.

# With the config file, we would get things like:

# https://semaphore-demo-staging-in5e2xu2k.now.sh/

# Aliases

# now ls

# Historical overview and rollbacks

Try deploying the staging site:

  #+BEGIN_SRC bash
  $ now --local-config staging.json

  > Deploying ~/semaphore-demo-zeit-now under myname
  > Using project semaphore-demo-staging
  > Synced 1 file (37B) [2s]
  > https://semaphore-demo-staging-hklhb6xbg.now.sh [v2] [3s]
  ┌ index.js                               Ready               [29s]
  └── λ index.js (473.97KB) [iad1]
  ┌ controllers/index.controller.js        Ready               [26s]
  └── λ controllers/index.controller.js (33.96KB) [iad1]
  > Ready! Aliased to https://semaphore-demo-staging.myname.now.sh [in clipboard] [37s]
  #+END_SRC

~now~ does all the heavy lifting:
- Uploads the code to Zeit Now.
- Downloads packages, builds and starts the app.
- Assigns deployment and public URLs.
# - Assigned a deployment URL. I got https://semaphore-demo-staging-hklhb6xbg.now.sh
# - Aliased the site to the public URL. I got: https://semaphore-demo-staging.myname.now.sh

Check out your new server, the Zeit Now dashboard shows all deployments:

[[./public/zeit-now-deployments-staging.png]]

# You see, I wasn't lying when I said it would be easy.

** What's all the buzz about Continuous Integration
   :LOGBOOK:
   CLOCK: [2019-04-29 Mon 18:44]--[2019-04-29 Mon 18:56] =>  0:12
   :END:

At this point in the post you may be asking:
I got the app online alright, aren't we done yet?
Not by a long shot, the best part is yet to come.
Think about all the things we did to get to this point. The first time it is always
interesting and fun, but doing it over again and again will get old fast.
Wouldn't it be great if we could automate away all of it?

This is exactly what continuous integration (CI) and continuous delivery (CD) are for.
CI/CD takes care of all the testing, building and deploying. And
they do it as a reproducible, battle-hardened process.

CI/CD is even more vital when working on a team. Lots of hands
code faster but have a higher chance of introducing conflicts.
The surest way to mitigate this is by building and testing app as frequently as possible.
Then, once everything is working, we can make high quality releases faster.
# half, on every update. Then, if everything goes right, releasing the new version
# early and quickly, the continuous delivery half.

# on a bigger project as part of a
# team.
# Once the team starts working on the code, you'll want to have a reliable way of
# verifying that it
# works as intended, so as you write new features you'll also write unit tests.
# But testing on each change is time consuming and error prone, not no to mention
# numbingly boring.
# Think how much complex things get when there is a whole team of developers
# working together. Each change can introduce errors on other parts of the code.
# When it's time to build the app, it fails. Integration hell

# # So far we haven't bothered a lot with testing.
# # So far we have been a lone wolf.

# # Now that I have your attention, let's start with some theory.
# # I promise it will be worth your time.
# # It will make you a better team member.

# # Working as a lone developer and as part of a team are two completely different beasts.
# # The lone developer, more likely than not, cares about making things work,
# # documentation and testing are second-class citizens. That won't roll when working on a team.
# # The developer has to think that other's will read his code, and he will
# # have to read other's people code also.
# # Many hands working on many parts of the code at the same time increase the
# # chance of conflicts. Which take time and effort to resolve, increase the time
# # to release software.

# # The answer is using a different mindset. Build


# # The lone developer has full control of the code, know what goes where and,
# # unless exceedingly disciplined, won't be writing little to no tests.

# # Things are so different on a team, especially a big one.
# # No developer can fit a whole big application in their brain.
# # So much things that don't matter that much before are now incredibly important:
# # documentation, testing, deployment, etc.

# So many hands working on the same project will eventually cause conflicts,
# not for nothing is called integration hell.
# New code will break things, patches will resurrect old bugs.
# Before long you'll be expending more time putting out fires and fixing bugs and
# less working on interesting things.

# Hopefully, so far everything has run smooothly.
# We used a demo project that we know works well and has been tested.
# Would it be that the life of a software developer is always so easy.

# Once we start working on improving the project,
# we need a way to ensure the new features work
# and, at the same time, that we're not breaking anything.

# For this we need to establish methods of reliable and frequent testing.
# There are multiple approachs to testing, the best teams include many in their projects:

# [ examine contents of requirements.txt here ? ]
# An interesting exercise is to examine the contents of ~requirements.txt~

# - Unit testing
# - Static code
# - Browser
# - Security

# Testing is part of the everyday life of a developer, that's just how it is. When done
# badly, it is tedious, ineffective and counter-productive.
# But proper testing brings a ton of benefits: stability, quality, fewer conflicts, less
# errors and confidence on the correctness of the code.


# We'll find errors earlier, spend
# more time buildings stuff instead of fixing it and have a higher confidence in
# the correctness of our code.

# Continuous integration (CI) is a programming discipline in which the application is
# built and tested each time code is modified. By making multiple small changes
# instead of a big one, problems are detected earlier and corrected faster.
# Such a paradigm, clearly, calls for an automated system to carry out all the
# steps. In such systems, code travels over a path, a pipeline, and it must pass an ever growing number of tests.

# But CI is more than testing and automation. CI calls for a different programming
# mindset and culture.

# - Early detection of errors
# - D

# It not only about testing or benefits, it's also about programming culture and discipline

# Doing all these tests as frequently as possible help detect errors quickly.
# Ideally, each time new code is pushed into the repository.
# However, testing is both tedious and error-prone. It would be a waste of valuable time
# manually testing everything all the time.

# Continuous Integration is a software development practice that enables us to
# automatically build and test our code.
# Instead of making big changes and then spending hours fixing errors and conflicts.
# We make small incremental changes and repeat all the tests.
# This gives us many benefits:

# - Detect and fix errors early.
# - Reduce conflicts, avoid integration hell.
# - Reduce time for releasing new versions
# - Improve quality and stability

# In the past, developers had to buy servers and manage infrastructure in order to do CI,
# which obviously increased costs beyond the reach of small teams.
# Fortunately, in this cloud enabled world, everyone can enjoy the benefits of CI.
# We'll see how we can use [[https://semaphoreci.com][Semaphore]] to add value to our project.

** About Semaphore

Semaphore is a cloud-based continuous integration and delivery platform.
It's a pleasure to work with: easy to use, powerful and blazing fast.
Being a hosted service, Semaphore requires no maintenance or administration.
Furthermore, it scales automatically to any workload.
Signing up with a GitHub account gets you $20 every month, which is more than
enough for our needs.
# It's very easy to use and fast and yet, very powerful.
# Semaphore only asks you to supply the config with the pipeline to run and it will take
# care of everything.
# will do them.
# ,, and Semaphore will take
# care of all the rest.

Before diving deep with Semaphore, we need to learn about a few key concepts.
Semaphore pipeline's are written in [[https://yaml.org/][YAML]], a text format that is easy for both humans
and computers to read.
When working with YAML, the important thing is to pay attention to indentation as,
in the same vein of Python, spaces do matter.

For our project, we only need to know about a few properties, if curious, you
may also check the [[https://docs.semaphoreci.com/article/50-pipeline-yaml][full pipeline spec]]:

# Pipelines file are written in YAML. It is a human-readable alternative to xml
# that is also easy to read by programs.
# The file consists of a series of nested key value lines.

- Name

Pipelines have ~name~ which is shown on Semaphore's
dashboard. We also have to set the config ~version~ number.
Right now the stable version is "v1.0".

  #+BEGIN_SRC yaml
  version: v1.0
  name: Build and test Express.js app
  #+END_SRC

- Agent

Semaphore offers several [[https://docs.semaphoreci.com/article/20-machine-types][machine types]] with different specs.
The combination of machine and operating system is defined under ~agent~ property.
Semaphore provides an [[https://docs.semaphoreci.com/article/32-ubuntu-1804-image][Ubuntu 18.04]] image that is just right
for our needs:

  #+BEGIN_SRC yaml
  agent:
    machine:
      type: e1-standard-2
      os_image: ubuntu1804
  #+END_SRC


- Blocks

Blocks, tasks and jobs define what to do at each step of the pipeline.
Each block must have a single task, and each task defines one of more jobs.
Jobs contain the list of commands to execute.
Within a block, jobs run concurrently, each one runs in a fully
isolated virtual machine.
Once all jobs in a block are done, the next block begins.
# If at least one job fails, the whole pipeline i

This is how a block with two jobs looks like:

  #+BEGIN_SRC yaml
  blocks:
    - name: Block name
      task:
        jobs:
        - name: My Job
          commands:
            - command 1
            - command 2
        - name: Another Job
          commands:
            - command 1
            - command 2
  #+END_SRC

# The pipelines used for our project are simpler than that. We only have one job
# per block.

# One of semaphore's core concepts (https://docs.semaphoreci.com/article/62-concepts)

# Now we have arrived at the heart of the pipeline: ~blocks~, ~tasks~ and ~jobs~.
# # what commands need to be executed to build, test and deploy our code.

# A pipeline is made of blocks.
# Blocks can have a name and must contain a task.
# A task contain jobs, and jobs are just a list of commands to execute.

# Blocks are started sequentially, one after the other.
# Within a block, jobs are executed in parallel.
# Each block only starts after all the jobs on the previous blocks have finished.

# Each on its own separate environment and filesystem (?)

# We can also define a different agent for each block. (?)
# Each task can have defined a different agent, regardless of the global agent we defined previously.


# At the top level, we have /blocks/. Blocks are executed sequentially, one after the other.
# Blocks contain one or more /Tasks/. All tasks within a block are executed in parallel.
# And tasks are made of one or more /Jobs/, which are also run sequentially and contain the
# actual command to run on Semaphore's machines.

# The heart of Semaphore CI are jobs.
# /Jobs/ are simply a commands to execute on the Semaphore servers.
# Jobs are grouped in /Tasks/. A task is just a list of commands to run one after the other.
# Tasks are, in turn, grouped in Blocks.
# A block is collection of one or more tasks that are run in parallel.

# **** Secrets

# Secrets can be used to store sensitive information such as passwords, tokens or
# API Keys. Semaphore encrypts the data and makes it available to the pipeline
# when required.

- [[https://docs.semaphoreci.com/article/67-deploying-with-promotions][Promotions]]

Promotions chain pipelines together to build complex workflows.
Since they can be triggered
by user-defined conditions, they can be used to gracefully manage failures
or to make a release when the pipeline runs successfully.
# Multiple promotions can branch out of a pipeline.
# We can use ~auto_promote_on~ to deploy the app after the pipeline runs successfully.
# We can use this to automatically deploy the app when the pipelines r
# For example, we can promote a deployment after the pipeline runs successfully:
# A pipeline can have multiple promotions and be triggered by different
# user-defined conditions, such as
# Promotions can be triggered manually or via user-defined conditions, such as all
# tests passing:
# The way they work is that, we define one or more promotions, with a reference
# to other pipeline files in the same repository.
  #+BEGIN_SRC yaml
  promotions:
    - name: Deploy
      pipeline_file: deploy.yml
      auto_promote_on:
        - result: passed
  #+END_SRC

** Continuous Integration Pipeline
   :LOGBOOK:
   CLOCK: [2019-04-28 Sun 13:13]--[2019-04-28 Sun 13:16] =>  0:03
   CLOCK: [2019-04-27 Sat 15:55]--[2019-04-27 Sat 16:03] =>  0:08
   :END:

In this section we'll review in detail our CI pipeline. Here's the full annotated config:

#+BEGIN_SRC yaml
# Use the latest stable version of Semaphore 2.0 YML syntax:
version: v1.0

# Name your pipeline. In case you connect multiple pipelines with promotions,
# the name will help you differentiate between, for example, a CI build phase
# and delivery phases.
name: Build and test Express.js app

# An agent defines the environment in which your code runs.
# It is a combination of one of available machine types and operating
# system images.
# See https://docs.semaphoreci.com/article/20-machine-types
# and https://docs.semaphoreci.com/article/32-ubuntu-1804-image
agent:
  machine:
    type: e1-standard-2
    os_image: ubuntu1804

# Blocks are the heart of a pipeline and are executed sequentially.
# Each block has a task that defines one or more jobs. Jobs define the
# commands to execute.
# See https://docs.semaphoreci.com/article/62-concepts
blocks:
  - name: Install dependencies
    task:
      jobs:
        - name: npm install and cache
          commands:
            # Get the latest version of our source code from GitHub:
            - checkout

            # Use the version of Node.js specified in .nvmrc.
            # Semaphore provides nvm preinstalled.
            - nvm use
            - node --version
            - npm --version

            # Restore dependencies from cache. This command will not fail in
            # case of a cache miss. In case of a cache hit, npm install will
            # run very fast.
            # For more info on caching, see https://docs.semaphoreci.com/article/68-caching-dependencies
            - cache restore client-node-modules-$SEMAPHORE_GIT_BRANCH-$(checksum package-lock.json),client-node-modules-$SEMAPHORE_GIT_BRANCH,client-node-modules-master
            - npm install

            # Store the latest version of node modules in cache to reuse in
            # further blocks:
            - cache store client-node-modules-$SEMAPHORE_GIT_BRANCH-$(checksum package-lock.json) node_modules

  - name: Run tests
    task:
      jobs:
        - name: npm test
          commands:
            - checkout
            - nvm use
            - cache restore client-node-modules-$SEMAPHORE_GIT_BRANCH-$(checksum package-lock.json),client-node-modules-$SEMAPHORE_GIT_BRANCH,client-node-modules-master
            - npm test

promotions:
  # Deployment to staging can be triggered manually:
  - name: Deploy to staging
    pipeline_file: deploy-staging.yml

  # Automatically deploy to production on successful builds on master branch:
  - name: Deploy to production
    pipeline_file: deploy-production.yml
    auto_promote_on:
      - result: passed
        branch:
          - master
#+END_SRC

*** Install dependencies
    :LOGBOOK:
    CLOCK: [2019-04-29 Mon 21:57]--[2019-04-29 Mon 22:06] =>  0:09
    :END:

#+BEGIN_SRC yaml
blocks:
  - name: Install dependencies
    task:
      jobs:
        - name: npm install and cache
          commands:
            - checkout
            - nvm use
            - node --version
            - npm --version
            - cache restore client-node-modules-$SEMAPHORE_GIT_BRANCH-$(checksum package-lock.json),client-node-modules-$SEMAPHORE_GIT_BRANCH,client-node-modules-master
            - npm install
            - cache store client-node-modules-$SEMAPHORE_GIT_BRANCH-$(checksum package-lock.json) node_modules
#+END_SRC

The first block downloads and installs all the required packages:

- [[https://docs.semaphoreci.com/article/54-toolbox-reference#checkout][checkout]] clones the code from GitHub.
- [[https://docs.semaphoreci.com/article/82-language-javascript-and-nodejs#supported-node-js-versions][nvm and npm]] are used to set Node.js version and install the packages.
- [[https://docs.semaphoreci.com/article/54-toolbox-reference#cache][cache]] is used to share node modules between jobs.

# ~cache~ plays a major role in our jobs. Since jobs run in a separate environment
# This is so because jobs within a block run in parallel, in a clean environment and independent filesystem.

# Just 2 blocks make the CI pipeline:

# #+caption: CI Pipeline
# #+name: CI Pipeline
# [[https://github.com/semaphoreci-demos/semaphore-demo-zeit-now/blob/master/images/semaphore-zeit-now-ci.png][CI Pipeline]]

# - npm install and cache:
#   - Downloads and installs the Node.js packages.
#   - Builds the app and saves it to the cache.

*** npm test

#+BEGIN_SRC yaml
  - name: Run tests
    task:
      jobs:
        - name: npm test
          commands:
            - checkout
            - nvm use
            - cache restore client-node-modules-$SEMAPHORE_GIT_BRANCH-$(checksum package-lock.json),client-node-modules-$SEMAPHORE_GIT_BRANCH,client-node-modules-master
            - npm test
#+END_SRC

This is the unit test block.
Since each job lives in an isolated environment, we need to repeatedly get the code and packages.
~npm test~ runs the Jest tests.

*** Deployments
    :LOGBOOK:
    CLOCK: [2019-04-27 Sat 16:03]--[2019-04-27 Sat 16:07] =>  0:04
    :END:

# Promotions connect pipelines to make more complex, multi-branch setups.
# The way they work is that, we define one or more promotions, with a reference
# to other pipeline files in the same repository.


#+BEGIN_SRC yaml
promotions:
  - name: Deploy to staging
    pipeline_file: deploy-staging.yml
  - name: Deploy to production
    pipeline_file: deploy-production.yml
    auto_promote_on:
      - result: passed
        branch:
          - master
#+END_SRC

Two [[https://docs.semaphoreci.com/article/50-pipeline-yaml#promotions][promotions]] branch out of the CI pipeline:

- Deploy to production: automatically started once all tests are green for the master branch.
- Deploy to staging: manually started from Semaphore's dashboard.

# At the end of a
# If all tests are gree, the end of the CI pipeline triggers an auto promotion for
# the production deployment.
# The end of the CI pipeline, if all tests have passed,

 # Once the CI pipeline completes successfully, an auto
 # [[https://docs.semaphoreci.com/article/50-pipeline-yaml#promotions][promotion]] kicks in and the
# production deployment starts.
# For staging, the promotion can be triggered manually.

** Putting it all together
   :LOGBOOK:
   CLOCK: [2019-04-29 Mon 22:06]--[2019-04-29 Mon 22:08] =>  0:02
   CLOCK: [2019-04-26 Fri 14:44]--[2019-04-26 Fri 14:51] =>  0:07
   :END:

Now that we have all the pieces of the puzzle in place,
you will see for yourself the power and convenience of CI/CD.
# we can see how much
# easier is to deploy with Semaphore. We only need one more thing.
# Time to put everything you learned so far in action.
# Here we'll use how much easier is to work with Semaphore:
# We want the following flow to happen:

# 1. You write code and push it to your team's repo
# 2. Semaphore grabs the code, runs the tests.
# 3. If everything's good, upload the new version to Zeit Now production
# 4. We'll have another version, a staging site to tests things safely, other
#    branchs, etc.

# If there was an error, we can see exactly what failed and when it failed,
# what was the last version that worked.

# If you haven't already,
# Open an account on Semaphore

*** A shared secret
    :LOGBOOK:
    CLOCK: [2019-04-27 Sat 12:11]--[2019-04-27 Sat 12:24] =>  0:13
    :END:

# Previously, we logged in to Zeit Now, to deploy.
# That won't work too well on Semaphore as we have an interactive console.
# For automation and scripts Zeit provides Tokens: secret strings to access your
# account programatically.

In order to connect Semaphore and Zeit Now, we need get a token:

# To generate a Token follow these steps:

1. Log in on your [[https://zeit.co][Zeit Now]] account
2. Go to *Settings*
3. Go to the *Tokens* tab.
4. Click on the *Create* button.
5. Enter a name for the token, maybe something descriptive like: semaphore-zeit-now

#+caption: Create token
#+name: Create token
[[./public/zeit-create-token.png]]

The token, being private information, does not belong in the repository.
Semaphore has a secure mechanism to handle secrets:

# Now all that remains is telling Semaphore about your Token:
1. Create an account for [[https://semaphoreci.com][Semaphore]] with your GitHub login.
2. On the left navigation bar, under *Configuration* click on *Secrets*.
3. Hit the *Create New Secret* button.
4. Create the secret as shown below:

#+caption: Create secret
#+name: Create secret
[[./public/semaphore-create-secret.png]]

*** Continuous Delivery Pipeline
      :LOGBOOK:
      CLOCK: [2019-04-28 Sun 13:16]--[2019-04-28 Sun 13:17] =>  0:01
      CLOCK: [2019-04-27 Sat 16:14]--[2019-04-27 Sat 16:21] =>  0:07
      :END:

We have two, almost identical, continuous delivery pipelines.
The only practical difference, apart from the name, is in the ~--local-config~
they use:

#+BEGIN_SRC yaml
# ~.semaphore/deploy-staging.yml

version: v1.0
name: Deploy to staging
agent:
  machine:
    type: e1-standard-2
    os_image: ubuntu1804
blocks:
  - name: Deploy to staging
    task:
      secrets:
        - name: now
      jobs:
      - name: Deploy to Zeit Now
        commands:
          - checkout
          - nvm use
          - npm install now -g
          - now --token $ZEIT_TOKEN --local-config staging.json
#+END_SRC


# - Production: ~semaphore-demo.USERNAME.now.sh~
# - Staging: ~semaphore-demo-staging.USERNAME.now.sh~

Deployment itself couldn't be easier:

- The token is decrypted and imported as ~$ZEIT_TOKEN~.
- ~npm~ installs the ~now~ tool.
- And ~now~ deploys takes care of the deployment.


# Zeit Now will download the packages, build and publish the application by itself.
# We don't need to do that.

#+caption: CD Pipeline
#+name: CD Pipeline
[[./public/semaphore-zeit-now-cd-production.png]]

# Both staging and production pipelines are practically identical.
# They only differ on the app ~name~, which maps to the final URL:
*** Start the pipeline
    :LOGBOOK:
    CLOCK: [2019-04-27 Sat 13:34]--[2019-04-27 Sat 13:36] =>  0:02
    :END:


    This is the where all our hard work pays off:

1. Go to your Semaphore account.
2. Follow the link on the sidebar to create a new project.
3. Semaphore will show your GitHub repositories, click on *Add Repository*.

  [[./public/semaphore-add-repository-zeit-now.png]]

5. The pipeline will start as soon as any file is modified on your repository:
# Edit any file and do a push to GitHub, Semaphore starts automatically.

  #+BEGIN_SRC bash
  $ touch any_file
  $ git add any_file
  $ git commit -m "start semaphore pipeline"
  $ git push origin master
  #+END_SRC

#+caption: CI+CD Pipelines
#+name: CI+CD Pipelines
[[./public/semaphore-zeit-now-ci-cd.png]]

Once all the blocks are done, you should have the production site online:
# Once deployment is completed, check out the new API service:

#+caption: Production
#+name: Production
[[./public/zeit-now-deployments-production.png]]

# That is it. There it is.

# *** Troubleshooting

# If you have any errors.

** You did it!

Nice work! Once you taste the power of CI/CD, you will want to use it in all
your projects. I hope that what you learned today helps you to build better and
smarter.
